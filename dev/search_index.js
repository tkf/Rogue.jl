var documenterSearchIndex = {"docs":
[{"location":"#Rogue.jl-1","page":"Home","title":"Rogue.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [Rogue]","category":"page"},{"location":"#Rogue.usein-Tuple{AbstractString}","page":"Home","title":"Rogue.usein","text":"Rogue.usein(downpath; dryrun, from, rev, commit, push)\n\nUpdate (Julia)Manifest.toml file(s) in a downstream project at downpath to use the current version of the upstream project.\n\nMake sure that the downstream project has no un-committed changes.\nIf manifests is nothing (default), find all JuliaManifest.toml and Manifest.toml file(s) that are tracked by git and have the upstream project as a dependency.\nUpdate the downstream manifest files (update git-tree-sha1).\nResolve dependencies.\nNote that this makes sure that the current version of the upstream project is available in the repository referenced by the downstream manifest files (i.e., git pushed).\nCommit the changed manifest files with a git commit message generated from the upstream commit.  In particular, it contains a URL to the commit page of the VCS hosting service used by the upstream project.\n\nArguments\n\ndownpath :: AbstractString: Path to the downstream project.\n\nKeyword Arguments\n\ndryrun :: Bool = false: If true, only print the operations that would be done.\nfrom :: AbstractString = \".\": Specify the location of the upstream project.\nrev :: AbstractString = \"HEAD\": Revision of the upstream project.\ncommit :: Union{Bool, Cmd} = true: If it is a Bool, it determines if the change should be committed.  If it is a Cmd, the change is committed and this is passed as options to the git commit command.\npush :: Union{Bool, Cmd} = false: Similar to commit but for git push.\n\n\n\n\n\n","category":"method"}]
}
